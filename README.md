<p float="left">
  <img src="https://media.giphy.com/media/XHAmkY1w4bX7qaH5wM/giphy.gif" width=320/>
  <img src="https://media.giphy.com/media/KGSgC0bNBhDtosNULQ/giphy.gif" width=320/> 
  <img src="https://media.giphy.com/media/LjzmHTSYEdK6MKCgH7/giphy.gif" width=320/>
</p>

Above gifs: Different algorithms searching for a path. 
The red line shows the discovered path.


### About
This repo compares different search-algorithms in random 2d-maze.
The maze is generated by starting from empty square 
and then adding walls of random length to random locations.

The goal is to find a path from corner to corner. Possible moves are up, down, left or right. 
Distance or length is measured with [manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry) 
which is the sum of vertical and horizontal lengths.

The compared algorithms are:
  
- [A-star](https://en.wikipedia.org/wiki/A*_search_algorithm) with a manhattan-distance heuristic which ignores walls
- [BFS](https://en.wikipedia.org/wiki/Breadth-first_search): breadth first search 
- [DFS](https://en.wikipedia.org/wiki/Depth-first_search): depth first search
   
Notes:
- BFS and A-star are guaranteed to find the shortest possible path if any path exists.
- in this case BFS is same as [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) because the distance between all connected nodes is uniform  

### Results

| finished   | algo   |    seconds |   n_explored |   length_path |   count |
|:-----------|:-------|-----------:|-------------:|--------------:|--------:|
| False      | A-star | 0.0124813  |      2397.05 |       nan     |     429 |
| False      | BFS    | 0.00818549 |      2397.05 |       nan     |     429 |
| False      | DFS    | 0.00808539 |      2397.05 |       nan     |     429 |
| True       | A-star | 0.0159034  |      2987.72 |       211.52  |     571 |
| True       | BFS    | 0.0244835  |      7104.2  |       211.52  |     571 |
| True       | DFS    | 0.0131783  |      3811.35 |       822.445 |     571 |

In this maze-setting DFS finds one path faster than the other two algorithms measured in wall clock time. 
However, that path is usually not the shortest. BFS and A-star always find the optimal path. 
A-star runs considerably faster than BFS both in wall clock time and in terms of explored nodes.

A-star explores nodes slightly slower than the other two algorithms because it has to maintain priority-queue to decide the next node to explore. 

### Running
All results can be repoduced with `runner.py`. 
Doesn't work in Windows and might require some dependencies.

------

##### Resources

- Introduction to A-star: https://www.redblobgames.com/pathfinding/a-star/introduction.html
- Animations with matplotlib
    - https://towardsdatascience.com/animations-with-matplotlib-d96375c5442c
    - https://towardsdatascience.com/how-to-create-animated-graphs-in-python-bb619cc2dec1 
 